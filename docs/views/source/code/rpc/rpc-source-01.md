---
title: 手写 RPC 01：从零实现到扩展性设计
date: 2025-05-23
tags:
  - 源码分析
  - Java
categories:
  - 源码 Source-code
isShowComments: true
---

<Boxx/>

在现代分布式系统中，RPC（Remote Procedure Call）框架是实现服务解耦、性能优化和资源统一调度的关键工具。本文将从零开始，手把手实现一个高性能、可扩展的 RPC 框架，并对关键技术点进行解析记录。

<!-- more -->

通过手写此项目代码，不仅增强了对rpc框架底层的理解，同时也对netty网络编程、组件扩展、框架设计等都有了一定的认识和了解。

我的项目源码地址参考：https://github.com/zpj80231/snail/tree/main/snail-source-code/source-rpc

[[toc]]

## 基础框架定义

- **自定义传输协议**：自定义消息格式，魔数、版本、序列化、压缩、消息体等基本内容。
- **自定义编解码器**：实现底层 `ByteBuf` 的读写，提高数据传输效率。
- **可扩展序列化/压缩算法**：通过 SPI 动态加载，不依赖第三方框架。
- **消息体传输设计**：统一请求、响应结构，兼容多种服务类型。
- **框架扩展性**：组件解耦，实现服务扩展。

## 服务端：服务暴露

- **自动服务扫描**：基于注解识别并注册服务。
- **注册中心集成**：
  - 默认内置本地文件注册中心（模拟 Zookeeper 路径方式）。
  - 支持扩展至 Nacos、Zookeeper 等第三方注册中心。
- **分组与版本管理**：接口支持多实现场景，通过 Group/Version 控制服务路由。
- **注解驱动式注册**：无需配置文件即可快速上线服务。

## 客户端：服务发现与调用

- **自动服务发现**：从注册中心拉取服务，支持分组与版本筛选。
- **负载均衡策略**：
  - 默认支持随机、轮询算法。
  - 可通过 SPI 接口动态扩展。
- **连接复用机制**：一个客户端对每个服务端只建立一个连接。
- **服务代理机制**：客户端调用远程方法如同调用本地方法，无感知。
- **远程调用封装**：统一处理请求封装、响应解析、异常管理。
- **多实例服务支持**：可同时启动多个服务端，实现负载均衡场景模拟。
- **优雅关闭**：服务端宕机时客户端自动感知并关闭连接。

## 动态扩展体系（基于 SPI）

- **序列化算法扩展**：默认支持 Java/JSON，可扩展为Kryo/Protobuf。
- **压缩算法扩展**：支持 Gzip 等任意压缩实现。
- **注册中心扩展**：SPI 接口实现统一抽象，便于接入第三方注册中心。
- **服务发现扩展**：对不同发现机制做统一封装，扩展性强。
- **负载均衡策略扩展**：任意算法都可以通过 SPI 接入，无缝切换。

## 技术要点解析

- 使用 **Netty** 实现异步高性能网络通信。
- **SPI + 反射机制** 实现可插拔模块结构。
- 所有模块都遵循接口设计，便于替换与扩展。
- 支持 **注解驱动式开发**，极大提升开发效率。

## 总结

本项目是一个学习和理解 RPC 框架设计的极佳实践材料。通过手动实现协议、注册中心、负载均衡、服务代理等模块，掌握现代 RPC 系统的运行原理和架构设计思路。

<Reward/>