(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{608:function(s,t,v){"use strict";v.r(t);var _=v(4),a=Object(_.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("Boxx"),s._v(" "),t("h2",{attrs:{id:"list和map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list和map"}},[s._v("#")]),s._v(" List和Map")]),s._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("1. 接口和抽象类之间的区别？")]),t("ol",[t("li",[t("p",[s._v("分别表示的"),t("strong",[s._v("类型不同")])]),s._v(" "),t("p",[s._v("接口："),t("strong",[s._v("interface")]),t("br"),s._v("\n抽象类："),t("strong",[s._v("class")])])]),s._v(" "),t("li",[t("p",[s._v("里面"),t("strong",[s._v("定义的属性修饰符不同")])]),s._v(" "),t("p",[s._v("接口：里面定义的属性默认都是静态的最终变量（public static final）"),t("br"),s._v("\n抽象类：里面定义的属性默认是（default）")])]),s._v(" "),t("li",[t("p",[s._v("里面"),t("strong",[s._v("定义的方法不同")])]),s._v(" "),t("p",[s._v("接口：里面定义的方法默认都是抽象方法（public abstarct）"),t("br"),s._v("\n从 jdk8.0开始 接口里面可以定义普通方法"),t("br"),s._v("\n抽象类：里面既可以定义抽象方法 又可以定义普通方法")])])])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("2. ArrayList和Vector之间的区别？")]),t("ul",[t("li",[t("p",[t("em",[t("strong",[s._v("Vector")])]),s._v("：同一时间允许单个线程进行访问 效率较低，但是不会出现并发错误"),t("br"),s._v(" "),t("em",[t("strong",[s._v("ArrayList")])]),s._v("：同一时间允许多个线程进行访问 效率较高，但是可能会出现并发错误")])]),s._v(" "),t("li",[t("p",[s._v("从jdk5.0开始 集合的工具类里面提供一个方法("),t("em",[t("strong",[s._v("synchronizedList")])]),s._v(") 可以将线程不安全的ArrayList对象变成线程安全的集合对象，于是Vector渐渐被淘汰")])])])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("3. ArrayList和LinkedList之间的区别？")]),t("ul",[t("li",[t("p",[t("em",[t("strong",[s._v("ArrayList")])]),s._v("：底层基于"),t("strong",[s._v("数组")]),s._v("实现的")]),s._v(" "),t("p",[s._v("优点：随机访问 遍历查找效率高"),t("br"),s._v("\n缺点：添加/删除元素")])]),s._v(" "),t("li",[t("p",[t("em",[t("strong",[s._v("LinkedList")])]),s._v("：底层基于"),t("strong",[s._v("链表")]),s._v("实现的")]),s._v(" "),t("p",[s._v("优点：添加/删除元素效率高"),t("br"),s._v("\n缺点：随机访问/遍历查找效率低")])]),s._v(" "),t("li",[t("p",[s._v("*：当正常开发的时候 尽量避免使用LinkedList里面的get(下标)方法")])])])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("4. HashMap和Hashtable之间的区别？")]),t("ol",[t("li",[t("p",[s._v("同步特性不同：")]),s._v(" "),t("ul",[t("li",[t("em",[t("strong",[s._v("HashMap")])]),s._v(" 同一时间允许多个线程进行访问 "),t("strong",[s._v("效率较高")]),s._v("，但是"),t("strong",[s._v("可能会出现并发错误")])]),s._v(" "),t("li",[t("em",[t("strong",[s._v("Hashtable")])]),s._v(" 同一时间允许一个线程进行访问 "),t("strong",[s._v("效率较低")]),s._v("，但是"),t("strong",[s._v("不会出现并发错误")])]),s._v(" "),t("li",[s._v("从jdk5.0开始，集合的工具类里面提供一个方法（"),t("em",[t("strong",[s._v("synchronizedList")])]),s._v("） 可以将线程不安全的HashMap对象变成线程安全的集合对象")])])]),s._v(" "),t("li",[t("p",[s._v("对null的要求不同")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("HashMap无论主键还是值都可以存放null")]),s._v("，但是由于主键唯一 所以主键只能添加一个null")]),s._v(" "),t("li",[s._v("Hashtable无论主键还是值都不能装null，一旦泛型里面装null 都会触发NullPointerException")])])]),s._v(" "),t("li",[t("p",[s._v("底层分组不同：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("HashMap底层数组大小默认为16")]),s._v("，程序员可以随意的定义，但是最终一定是2的n次方数")]),s._v(" "),t("li",[s._v("Hashtable底层数组大小默认为11，程序员可以随意定义")])])]),s._v(" "),t("li",[t("p",[s._v("出现的版本不同")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("Hashtable：since jdk1.0")])]),s._v(" "),t("li",[t("strong",[s._v("HashMap：since jdk1.2")])])])])])]),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("5. hashmap 红黑树")]),t("ul",[t("li",[t("p",[s._v("负载因子，代表了table的填充度有多少，默认是0.75")]),s._v(" "),t("p",[s._v("加载因子存在的原因，还是因为减缓哈希冲突，提高查询效率。如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。\n所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。")])]),s._v(" "),t("li",[t("p",[s._v("为何HashMap的数组长度一定是2的次幂（减少hash碰撞）")]),s._v(" "),t("p",[s._v("扩容时需要重新计算数组索引index = h&(length-1)，需要进行大量的与运算，保证2的次幂，可以保证在进行与运算时，(length-1)的值的二进制所有的位均为1，这种情况下，Index的结果等于hashCode的最后几位。只要输入的hashCode本身符合均匀分布，Hash算法的结果就是均匀的。")])])])]),t("h2",{attrs:{id:"泛型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[s._v("#")]),s._v(" 泛型")]),s._v(" "),t("details",{staticClass:"custom-block details"},[t("summary",[s._v("1. 泛型中的通配符 T，E，K，V，？")]),t("p",[s._v("本质上这些个都是通配符，没啥区别，换成 A-Z 之间的任何一个 字母都可以。"),t("br"),s._v("\n通常情况下，T，E，K，V，？ 是这样约定的：")]),s._v(" "),t("ul",[t("li",[s._v("？ 表示不确定的 java 类型")]),s._v(" "),t("li",[s._v("T (type) 表示具体的一个java类型")]),s._v(" "),t("li",[s._v("K V (key value) 分别代表java键值中的Key Value")]),s._v(" "),t("li",[s._v("E (element) 代表Element")])]),s._v(" "),t("blockquote",[t("p",[s._v("可参考："),t("a",{attrs:{href:"https://juejin.im/post/5d5789d26fb9a06ad0056bd9#heading-1",target:"_blank",rel:"noopener noreferrer"}},[s._v("掘金"),t("OutboundLink")],1)])])])],1)}),[],!1,null,null,null);t.default=a.exports}}]);